     React Hook 
**********************************************************************************************************************************************************************************************************************
\\\\useState\\\\
=================================================================================================================================================================================

The useState Hook is a fundamental building block for managing state within functional components in React. 
It allows you to declare and manage state variables directly within a function component, eliminating the 
need for class-based components in many cases.


function Counter() {
    const [count, setCount] = useState(0);

    const handleClick = () => {
        setCount(count + 1); // Update state by incrementing
    };

    return (
        <div>
            <p>You clicked {count} times</p>
            <button onClick={handleClick}>Click me</button>
        </div>
    );
}
**********************************************************************************************************************************************************************************************************************

\\\\useRef\\\\
=================================================================================================================================================================================
The useRef Hook is another essential tool in React's arsenal. It allows you to create a mutable reference object that persists 
throughout the lifecycle of a component. Unlike useState, changes to a useRef object don't trigger re-renders, making 
it ideal for scenarios where you need to:

{{{Access DOM elements directly}}}
======================================
Assign a useRef to an HTML element using the ref attribute.
Access the DOM element later using the .current property of the ref object. This is useful for manual DOM manipulation or integrating with third-party libraries.

import React, { useRef } from 'react';

function InputFocus() {
    const inputRef = useRef(null);

    const focusInput = () => {
        inputRef.current.focus();
    };

    return (
        <div>
            <input type="text" ref={inputRef} />
            <button onClick={focusInput}>Focus Input</button>
        </div>
    );
}


{{{Store Mutable Values:}}}
============================
While not meant for frequent updates that drive UI changes, you can use useRef to store values that need to persist 
across re-renders but don't necessarily cause re-renders themselves. This could be animation frames, timers, or
previous calculations.

import React, { useRef } from 'react';

function AnimationFrame() {
    const frameCountRef = useRef(0); // Initial value

    useEffect(() => {
        const updateFrame = () => {
            frameCountRef.current++;
            // Use frameCountRef.current for animation logic
            requestAnimationFrame(updateFrame);
        };
        requestAnimationFrame(updateFrame);

        return () => cancelAnimationFrame(updateFrame); // Cleanup
    }, []);

    return (
        <div>
            {/* Display animation using frameCountRef.current */}
        </div>
    );
}

{{{Measure DOM Elements:}}}
================================
You can use useRef to store the dimensions of a DOM element after it's been rendered.

import React, { useRef, useEffect } from 'react';

function ImageSize() {
    const imageRef = useRef(null);
    const [width, setWidth] = useState(0);
    const [height, setHeight] = useState(0);

    useEffect(() => {
        if (imageRef.current) {
            setWidth(imageRef.current.clientWidth);
            setHeight(imageRef.current.clientHeight);
        }
    }, [imageRef.current]); // Update on ref change

    return (
        <div>
            <img ref={imageRef} src="..." alt="..." />
            <p>Width: {width}, Height: {height}</p>
        </div>
    );
}
**********************************************************************************************************************************************************************************************************************

\\\useEffect\\\
=======================================================================================================================================================
The useEffect Hook in React is a powerful tool for performing side effects in functional components. 

Side effects are actions that can't be directly done within the component rendering process, such as:

1)Data Fetching: Fetching data from APIs or external sources.
2)Subscriptions: Setting up subscriptions to external data sources (e.g., WebSockets).
3)Timers: Creating timers or intervals that update the UI.
4)DOM Manipulation: Directly manipulating the DOM outside of React's reconciliation process (use sparingly).
5)Cleanup: Performing cleanup tasks when a component unmounts (e.g., clearing timers, removing event listeners).

A)Running Code After Render (Similar to componentDidMount and componentDidUpdate):
================================================================================

import React, { useState, useEffect } from 'react';

function FetchData() {
    const [data, setData] = useState(null);

    useEffect(() => {
        const fetchData = async () => {
            const response = await fetch('https://api.example.com/data');
            const data = await response.json();
            setData(data);
        };
        fetchData();
    }, []); // Empty array: runs only on initial render

    return (
        <div>
            {data ? (
                <p>Data: {JSON.stringify(data)}</p>
            ) : (
                <p>Loading data...</p>
            )}
        </div>
    );
}

B) Cleanup Function:
====================
You can optionally return a function from useEffect. This function is called when the 
component unmounts or before the effect runs again if the dependencies change. It's 
useful for cleaning up side effects, like canceling timers or removing event listeners.

useEffect(() => {
    const listener = () => {
        // Do something on window resize
    };
    window.addEventListener('resize', listener);

    return () => window.removeEventListener('resize', listener); // Cleanup
}, []);
********************************************************************************************************************************************************************************************************************
