     React Hook 
**********************************************************************************************************************************************************************************************************************
AA\\\\useState\\\\
=================================================================================================================================================================================

The useState Hook is a fundamental building block for managing state within functional components in React. 
It allows you to declare and manage state variables directly within a function component, eliminating the 
need for class-based components in many cases.


function Counter() {
    const [count, setCount] = useState(0);

    const handleClick = () => {
        setCount(count + 1); // Update state by incrementing
    };

    return (
        <div>
            <p>You clicked {count} times</p>
            <button onClick={handleClick}>Click me</button>
        </div>
    );
}
**********************************************************************************************************************************************************************************************************************

BB\\\\useRef\\\\
=================================================================================================================================================================================
The useRef Hook is another essential tool in React's arsenal. It allows you to create a mutable reference object that persists 
throughout the lifecycle of a component. Unlike useState, changes to a useRef object don't trigger re-renders, making 
it ideal for scenarios where you need to:

{{{Access DOM elements directly}}}
======================================
Assign a useRef to an HTML element using the ref attribute.
Access the DOM element later using the .current property of the ref object. This is useful for manual DOM manipulation or integrating with third-party libraries.

import React, { useRef } from 'react';

function InputFocus() {
    const inputRef = useRef(null);

    const focusInput = () => {
        inputRef.current.focus();
    };

    return (
        <div>
            <input type="text" ref={inputRef} />
            <button onClick={focusInput}>Focus Input</button>
        </div>
    );
}


{{{Store Mutable Values:}}}
============================
While not meant for frequent updates that drive UI changes, you can use useRef to store values that need to persist 
across re-renders but don't necessarily cause re-renders themselves. This could be animation frames, timers, or
previous calculations.

import React, { useRef } from 'react';

function AnimationFrame() {
    const frameCountRef = useRef(0); // Initial value

    useEffect(() => {
        const updateFrame = () => {
            frameCountRef.current++;
            // Use frameCountRef.current for animation logic
            requestAnimationFrame(updateFrame);
        };
        requestAnimationFrame(updateFrame);

        return () => cancelAnimationFrame(updateFrame); // Cleanup
    }, []);

    return (
        <div>
            {/* Display animation using frameCountRef.current */}
        </div>
    );
}

{{{Measure DOM Elements:}}}
================================
You can use useRef to store the dimensions of a DOM element after it's been rendered.

import React, { useRef, useEffect } from 'react';

function ImageSize() {
    const imageRef = useRef(null);
    const [width, setWidth] = useState(0);
    const [height, setHeight] = useState(0);

    useEffect(() => {
        if (imageRef.current) {
            setWidth(imageRef.current.clientWidth);
            setHeight(imageRef.current.clientHeight);
        }
    }, [imageRef.current]); // Update on ref change

    return (
        <div>
            <img ref={imageRef} src="..." alt="..." />
            <p>Width: {width}, Height: {height}</p>
        </div>
    );
}
**********************************************************************************************************************************************************************************************************************

CC\\\useEffect\\\
=======================================================================================================================================================
The useEffect Hook in React is a powerful tool for performing side effects in functional components. 

Side effects are actions that can't be directly done within the component rendering process, such as:

1)Data Fetching: Fetching data from APIs or external sources.
2)Subscriptions: Setting up subscriptions to external data sources (e.g., WebSockets).
3)Timers: Creating timers or intervals that update the UI.
4)DOM Manipulation: Directly manipulating the DOM outside of React's reconciliation process (use sparingly).
5)Cleanup: Performing cleanup tasks when a component unmounts (e.g., clearing timers, removing event listeners).

A)Running Code After Render (Similar to componentDidMount and componentDidUpdate):
================================================================================

import React, { useState, useEffect } from 'react';

function FetchData() {
    const [data, setData] = useState(null);

    useEffect(() => {
        const fetchData = async () => {
            const response = await fetch('https://api.example.com/data');
            const data = await response.json();
            setData(data);
        };
        fetchData();
    }, []); // Empty array: runs only on initial render

    return (
        <div>
            {data ? (
                <p>Data: {JSON.stringify(data)}</p>
            ) : (
                <p>Loading data...</p>
            )}
        </div>
    );
}

B) Cleanup Function:
====================
You can optionally return a function from useEffect. This function is called when the 
component unmounts or before the effect runs again if the dependencies change. It's 
useful for cleaning up side effects, like canceling timers or removing event listeners.

useEffect(() => {
    const listener = () => {
        // Do something on window resize
    };
    window.addEventListener('resize', listener);

    return () => window.removeEventListener('resize', listener); // Cleanup
}, []);
********************************************************************************************************************************************************************************************************************

DD\\\useReducer\\\
========================================================================================================================================================
The useReducer Hook in React provides a powerful alternative to useState for managing
complex state logic, especially when dealing with multiple interrelated pieces of state.
Here's a breakdown of its functionalities:
>State management
>Improved readability

Reducer Function:
=================
const reducer = (state, action) => {
    switch (action.type) {
        case 'increment':
            return { count: state.count + 1 };
        case 'decrement':
            return { count: state.count - 1 };
        default:
            return state;
    }
};


Using useReducer:
=================
import React, { useReducer } from 'react';

function Counter() {
    const [state, dispatch] = useReducer(reducer, { count: 0 });

    const handleIncrement = () => {
        dispatch({ type: 'increment' });
    };

    const handleDecrement = () => {
        dispatch({ type: 'decrement' });
    };

    return (
        <div>
            <p>Count: {state.count}</p>
            <button onClick={handleIncrement}>Increment</button>
            <button onClick={handleDecrement}>Decrement</button>
        </div>
    );
}


Dispatching Actions:
====================
const handleIncrement = () => {
    dispatch({ type: 'increment' }); // Dispatch the 'increment' action
};


**********************************************************************************************************************************************************************************************************************

EE\\\ useContext\\\
==================================================================================================================================
The useContext Hook is a powerful tool for managing and sharing data across components 
in React applications without prop drilling. It allows functional components to access 
data provided by a parent component several levels above in the component hierarchy.

A) Creating Context:
=====================
Use React.createContext() to create a context object. This object serves as a container
for the data you want to share.

import React, { createContext } from 'react';

const ThemeContext = createContext({
    theme: 'light',
    toggleTheme: () => {} // Placeholder for theme toggle function
});

B) Providing Context:
======================
Wrap the part of your component tree where you want to make the context data available
with a provider component. Pass the actual data you want to share as a prop to the provider.

function App() {
    const [theme, setTheme] = useState('light');

    const toggleTheme = () => {
        setTheme(theme === 'light' ? 'dark' : 'light');
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            {/* Your components that need theme data */}
        </ThemeContext.Provider>
    );
}

C) Consuming Context:
=====================
In any component within the provider hierarchy, you can use the useContext Hook to access
the context data. This hook takes the context object as an argument and returns the current
value of the context.

import React, { useContext } from 'react';

function Toolbar() {
    const { theme, toggleTheme } = useContext(ThemeContext);

    return (
        <div>
            <button onClick={toggleTheme}>Toggle Theme ({theme})</button>
        </div>
    );
}
*******************************************************************************************************************************************************************
